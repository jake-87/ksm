# The KSM language spec

Read this in raw mode.

## part 1: the vm

### registers

the vm does not have the concert of registers; however, 01 is where many operators place output, and 00 is the program counter.

### memory

The VM should have some amount bytes of memory, such that `1024 <= mem_size <= infinity`.
The memory should be at least 32 bits. Any value above this is undefined, and implimentations should not rely on this. Code should not rely on values being zerod when leftshifted.

### opcodes

Opcodes are formed by a sequence of 8 bytes, like so:

`02 b7 55 00`

The first is the opcode, the other three are operands.

### types of opcodes

If the argument should be left blank, it is signified with zeros.

### Modes:

01 - Memory -> memory 

02 - Literal -> memory,

03 - Literal -> literal ( only for add, multiply, etc )

### Conventions:

xx, yy, zz -> Arguments

mm -> Mode

## Opcodes

00 xx yy mm -> mov des src mode

01 xx 00 00 -> inc src

02 xx 00 00 -> dec src

03 xx yy mm -> add arg1 arg2 mode, result in memory address 01

04 xx yy mm -> sub arg1 arg2 mode, result in memory address 01

05 xx yy mm -> mul arg1 arg2 mode, result in memory address 01

06 xx yy mm -> div arg1 arg2 mode, result in memory address 01

07 xx yy mm -> cmp arg1 arg2 mode

08 xx yy zz -> jmp val1 val2 val3, jmp location is generated by concat of val1 val2 val3, 12 54 ab -> jump to location 1254ab

09 xx yy zz -> jmpz val1 val2 val3, see jmp for concat rules

0a xx yy zz -> jmpnz val1 val2 val3, see jmp for concat rules

0b xx mm 00 -> write arg1 mode 00, writes to stdout

0c xx 00 00 -> read arg1 00 00, reads a number or char into arg1

0d xx mm 00 -> hlt arg1 mode 00, halts with return code arg1 or content of arg1, depending on mode

0e xx yy zz -> store arg1 arg2 arg3, move content of memory address 01 into memory address arg1 + arg2 + arg3, see jmp for rules

0f xx yy zz -> load arg1 arg2 arg3, move content of memory address arg1 + arg2 + arg3 into memory address 01, see jmp for rules

10 xx yy zz -> xor arg1 arg2 mode, xor arg1 with arg2, result in memory address 01

11 xx yy zz -> and arg1 arg2 mode, and arg1 with arg2, result in memory address 01

12 xx yy zz -> or arg1 arg2 mode, or arg1 with arg2, result in memory address 01

13 xx mm 00 -> not arg1 mode 00, not arg1, result in memory address 01

14 xx yy zz -> bsl arg1 arg2 mode, bitshift arg1 arg2 bits left

15 xx yy zz -> bsr arg1 arg2 mode, bitshift arg1 arg2 bits right




